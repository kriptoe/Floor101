{"version":3,"sources":["../../src/index.ts","../../../node_modules/websocket/lib/browser.js","../../../node_modules/es5-ext/global.js","../../../node_modules/websocket/lib/version.js","../../../src/internal/websocket-backfiller.ts","../../../src/api/alchemy-websocket-provider.ts","../../src.ts/browser-ws.ts","../../src.ts/websocket-provider.ts"],"names":["url","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","SturdyWebSocket","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","Array","isArray","this","protocols","applyDefaultOptions","wsConstructor","WebSocket","Error","openNewWebSocket","binaryTypeInternal","binaryType","ws","sum","bufferedAmount","hasUnknownAmount","forEach","data","byteLength","length","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","protocol","close","code","reason","disposeSocket","shutdown","send","readyState","push","reconnect","handleClose","undefined","addEventListener","type","listener","dispatchEvent","event","dispatchEventOfType","removeEventListener","filter","l","connectTimeout","handleError","handleMessage","handleOpen","connectTimeoutId","setTimeout","clearConnectTimeout","allClearResetTime","message","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","then","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","Math","max","min","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","console","log","s","DEFAULT_OPTIONS","Number","POSITIVE_INFINITY","result","Object","keys","key","value","_globalThis","globalThis","require","error","window","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop","defineProperty","get","module","exports","naiveFallback","self","prototype","configurable","__global__","version","WebsocketBackfiller","provider","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","getBlockNumber","toBlockNumber","getHeadEventsInRange","maxBackfillBlocks","lastSeenBlockNumber","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","previousLogs","getLogsInRange","blockNumber","getCommonAncestor","commonAncestor","removedLogs","map","removed","fromBlockInclusive","NEGATIVE_INFINITY","addedLogs","logIndex","newMax","blockNumberHex","toBlockExclusive","batchParts","i","method","params","sendBatch","blockHeads","toNewHeadsEvent","oldEvent","getBlockByNumber","blockHead","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","dedupeLogs","items","getKey","keysSeen","Set","item","has","add","CANCELLED","AlchemyWebSocketProvider","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","process","versions","node","w3cwebsocket","ethersNetwork","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","JSON","parse","jsonrpc","id","isResponse","isSubscriptionEvent","physicalId","subscription","virtualId","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","emitEvent","clear","cancelled","cancel","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","startHeartbeat","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","eventName","_addEventListener","_off","_removeAllListeners","_listenerCount","_listeners","once","_events","_startEvent","includes","customStartEvent","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","subId","resolvedParams","set","sentEvents","_subs","args","stopped","eventTag","apply","_stopEvent","parts","nextId","payload","sendBatchConcurrently","removeSocketListeners","stopHeartbeatAndBackfill","e","listenerCount","_websocket","handleReopen","withBackoffRetries","withTimeout","getNewHeadsBackfill","backfillEvents","emitNewHeadsEvent","getLogsBackfill","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","setInterval","req","fromAddress","toAddress","hashesOnly","_subscribe","PENDING_TRANSACTIONS","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","emit","from","toNumber","_emitted","block","formatter","filterLog","removeAllListeners","found","getNetworkFromEthers","f","retryCount","shouldRetry","nextWaitTime","delay","ms","resolve","promise","race","_","reject","currentBlockNumber","firstGoodIndex","findIndex","splice","logger","throwError","errors","UNSUPPORTED_OPERATION","operation"],"mappings":"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","file":"static/js/4.680eec56.chunk.js","sourcesContent":["export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","module.exports = require('../package.json').version;\n","import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map"],"sourceRoot":""}